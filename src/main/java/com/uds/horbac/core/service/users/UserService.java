package com.uds.horbac.core.service.users;

import com.uds.horbac.core.dao.employees.EmployeeRepository;
import com.uds.horbac.core.dao.organizations.OrganizationRepository;
import com.uds.horbac.core.dao.units.AdministrativeUnitRepository;
import com.uds.horbac.core.dao.users.UserRepository;
import com.uds.horbac.core.entities.employees.Appoints;
import com.uds.horbac.core.entities.employees.Employee;
import com.uds.horbac.core.entities.organizations.Organization;
import com.uds.horbac.core.entities.units.AdministrativeUnit;
import com.uds.horbac.core.entities.users.*;
import com.uds.horbac.core.exceptions.ApiException;
import com.uds.horbac.core.rest.users.GroupName;
import com.uds.horbac.core.rest.users.RoleName;
import com.uds.horbac.core.service.employees.AppointsService;
import com.uds.horbac.core.service.employees.EmployeeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Generated by Spring Data Generator on 31/12/2020
 */
@Service
public class UserService implements UserDetailsService {
    //private final Logger logger = LoggerFactory.getLogger(UserService.class);
	
	/*@Autowired
	private ImageStorageService imageStorageService;
	*/

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    EmployeeService employeeService;

    @Autowired
    GroupRepository groupRepository;

    @Autowired
    RoleRepository roleRepository;

    @Autowired
    EmployeeRepository employeeRepository;

    @Autowired
    AppointsService appointsService;

    @Autowired
    AdministrativeUnitRepository administrativeUnitRepository;

    @Autowired
    OrganizationRepository organizationRepository;

    @Transactional
    public User create(User user0, Employee empl) {

        empl = employeeRepository.save(empl);

        Set<Group> groups = new HashSet<>(groupRepository.findAll());
        String email = user0.getEmail();
        Set<Role> roles = new HashSet<>(roleRepository.findAll());
        //check if there exists users, if not the first user is the boss
        long count = userRepository.countAll();
        User user = User.builder().employee(empl).username(user0.getUsername())
                .accountNonExpired(true)
                .accountNonLocked(true)
                .credentialsNonExpired(true)
                .active(true).enabled(true).password(
                        passwordEncoder.encode(user0.getPassword())
                ).email(email).build();
        if (count == 0L) {
            //no user has been saved yet
            Organization org = organizationRepository.findByIsDefault(true);

            if (org == null) {
                throw new ApiException("The organization has not been initialized. Initialize it and try again.");
            }
            AdministrativeUnit root = administrativeUnitRepository.findBykeyAndOrganizationId("root", org.getId());
            if (root == null) {
                throw new ApiException("The organization has not been initialized. Initialize it and try again.");
            }
            org.setOwner(empl);
            org = organizationRepository.save(org);
            appointsService.create(
                    Appoints.builder().organization(org).adminUnit(root).employee(empl).build()
            );
            user.setRoles(roles);
            user.setGroups(groups);
        } else {
            //ordinary employee
            roles = roles.stream().filter(r -> !r.getName().equals(RoleName.OWNER) && !r.getName().equals(RoleName.ADMIN) && !r.getName().equals(RoleName.ACTIVITI_ADMIN)
            ).collect(Collectors.toSet());
            user.setRoles(roles);
            groups = groups.stream().filter(g -> !g.getName().equals(GroupName.ADMIN)).collect(Collectors.toSet());
            user.setGroups(groups);
        }


        if (userRepository.existsByUsername(user0.getUsername())) {
            System.out.println("PROBLEME");
        }
        return userRepository.save(user);
    }

    public boolean remove(Long id) {
        Optional<User> user = userRepository.findById(id);
        if (user.isPresent()) {
            userRepository.delete(user.get());
            return true;
        } else {
            return false;
        }
    }


    public User toggleActive(Long id) throws ApiException {
        Optional<User> user = userRepository.findById(id);
        if (user.isPresent()) {
            User aUser = user.get();
            aUser.setActive(!aUser.getActive());
            return userRepository.save(aUser);
        } else {
            throw new ApiException("User not found");
        }
    }

    public User updatePassword(Long idUser, String oldPassword, String newPassword) throws ApiException {
        Optional<User> user = userRepository.findById(idUser);
        if (user.isPresent()) {
            User aUser = user.get();
            String encode_newpwd = passwordEncoder.encode(newPassword);
            //String encode_oldpwd = passwordEncoder.encode(oldPassword);

            //test if the passwords match!!

            if (passwordEncoder.matches(oldPassword, aUser.getPassword())) {
                aUser.setPassword(encode_newpwd);
                return userRepository.save(aUser);
            } else {
                System.out.println("PASWORD DOES NOT MATCH............." + oldPassword + "   " + aUser.getPassword());
                throw new ApiException("Bad password");
            }
        } else {
            throw new ApiException("Account not found");
        }
    }

    public User resetPassword(Long idUser, String newPassword) throws ApiException {
        Optional<User> user = userRepository.findById(idUser);
        if (user.isPresent()) {
            User aUser = user.get();
            aUser.setPassword(passwordEncoder.encode(newPassword));
            return userRepository.save(aUser);
        } else {
            throw new ApiException("Account not found");
        }
    }

    public User get(Long id) throws ApiException {
        try {
            Optional<User> optionalUser = userRepository.findById(id);
            if (optionalUser.isPresent()) {
                return optionalUser.get();
            } else {
                throw new ApiException("Account not found");
            }
        } catch (IllegalArgumentException e) {
            throw new ApiException("Account not found");
        }
    }


    public boolean existsByUserName(String name) {
        return userRepository.existsByUsername(name);
    }

    public List<User> getAll() {
        return userRepository.findAll();
    }

    public List<User> filterUsers(String query) {
        return userRepository.filterUsers(query);
    }

/*
	public Resource getAvatar(Long userId) throws ApiException {
		User user = this.get(userId);
		if(user.getPerson() != null && user.getPerson().getPhotoPath() != null) {
			return imageStorageService.loadImageAsResource(user.getPerson().getPhotoPath());
		}
		else {
			throw U2gGlobals.throwError(U2gConstants.IMAGE_NOT_FOUND, HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}
	*/

    public Optional<User> getUserByEmployee(Employee employee) {
        return userRepository.findByEmployee(employee);
    }

    @Override
    public User loadUserByUsername(String username) {
        try {
            User us = userRepository.findByUsername(username).get();
            return us;
        } catch (Exception e) {
            return null;
        }

    }


}
